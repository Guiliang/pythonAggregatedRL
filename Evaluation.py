"""
Some utilities for evaluating RL related things

David Johnston 2015
"""

import numpy as np
import csv

def conditionalTransitions(T,agg):
    """
    Calculates nxn first order and nxnxn second order conditional transition matrices from 
    NxN matrix and size n aggregation agg.
    Assumes that T^n.[1,0,...] gives stationary distribution of T for large n (true for 
    aggregations randomly generated by script in this package)
    """
    N = len(T)
    n = agg['n']
    
    pw = 100
    st_dist = np.linalg.matrix_power(T,pw)[0]

    st_i_1 = stochasticInverse(agg,st_dist)

    c1T = aggregatedTransition(T,st_i_1,agg)
    for row in c1T:
        assert abs(1-sum(row)) < 1e-7, "{}, occ = {}, T={}".format(c1T,st_i_1,T)


    c2T = np.zeros((n,n,n))

    for i in range(n):
        dist_i = st_i_1[i].dot(T)
        st_i_2 = stochasticInverse(agg,dist_i)
        c2T[i] = aggregatedTransition(T,st_i_2,agg)
        for row in c2T[i]:
            assert abs(1-sum(row)) < 1e-7 or sum(row) == 0, "{}, occ = {}".format(c2T[i],st_i_2)

    return c1T, c2T


def stochasticInverse(agg,occupation):
    """
    Given underlying state occupation, calculate stochastic inverse
    """
    N = len(occupation)
    stoch_inv = np.zeros((agg['n'],N))

    for state, agg_s in agg.items():
        if state != 'n':
            stoch_inv[agg_s][state] = occupation[state]

    for agg_s_occ in stoch_inv:
        if sum(agg_s_occ) > 0:
            agg_s_occ /= sum(agg_s_occ)

    return stoch_inv
        
        
def aggregatedTransition(T,stoch_inv,agg):
    """
    Calculates an nxn transition matrix given NxN transition matrix T,
    size N vector occupation and size n aggregation agg
    """
    n = agg['n']
    aT = np.zeros((n,n))
    
    for agg_s, occ in enumerate(stoch_inv):
        
        t = occ.dot(T)
        #print t, occ
        
        t_agg = np.zeros(n)
        for i, s in enumerate(t):
            t_agg[agg[i]] += s
        
        aT[agg_s] = t_agg
        
    return aT

def KLDiv(p1,p2):
    """
    Computes KL divergence of discrete distributions p1 and p2. p1 and p2 are numpy arrays,
    and it is assumed that p1[0] == p1(0).
    """

    p2_copy = np.copy(p2)
    p1_copy = np.copy(p1)
    for i, p in enumerate(p2):
        assert p>0 or p1[i]==0, "p2={}, p1={}".format(p, p1[i]) # p2 == 0 => p1 == 0
        if p1[i] == 0:
            p1_copy[i] = 1
            p2_copy[i] = 1 # This will cause log(p1/p2) to evaluate to 0

    r = p1_copy/p2_copy
    d_vec = p1*np.log(r)
    d = sum(p1*np.log(r))
    assert d>=-1e-10, "sum p1 = {}, sum p2 = {}, dv={}, r={}".format(p1,p2,d_vec, r)
    return d

def nonMarkovianity(T,agg):
    """
    Given transition matrix T and aggregation agg,
    calculates the average KL divergence between transitions conditioned on one and 
    two steps.
    """
    
    tr1, c2 = conditionalTransitions(T,agg)

    tot = 0
    n = len(T)

    for i, tr2 in enumerate(c2):
        for j, p in enumerate(tr2):
            if sum(p)>0:
                tot += KLDiv(p,tr1[j])

    return tot/n/n




def getDeltas(agent,problem,agg=None):
    """
    Gets matrix |qhat(s,a)-q*(s,a)| for all s, a
    qhat is agent's estimated q-value, q^* is actual q-value
    """
    
    if problem.qValues!=None:
        qstar = problem.qValues.T
    else:
        assert isinstance(problem, MDP)
        vi_agent = VIAgent(problem)
        vi_agent.VISweep()
        qstar = vi_agent.qValues

    if agg:
        qhat = np.array([ agent.qValues[agg[j]] for j in range(problem.rawStates)])
    else:
        qhat = agent.qValues

    assert qhat.shape == qstar.shape, "qhat {}, qstar {}".format(qhat.shape,qstar.shape)

    return abs(qhat-qstar)


def writeContourData(agg,filename):
    """
    Writes a csv with x, xdot, class triples
    for plotting aggregation contours
    """
    xold = 0

    del agg['n']
    del agg['term']

    with open(filename,"wt") as outfile:
        csvw = csv.writer(outfile)
        csvw.writerow(['x','xdot','class'])
        for (xdot, x), c in agg.items():
            if x != xold:
                csvw.writerow([])
                xold = x
            csvw.writerow([x,xdot,c])
